# Numpy



## `Numpy`란 : Numerical Python

- C언어로 구현된 파이썬 라이브러리(외부 라이브러리)
- `고성능 수치계산을 위해 만들어진 파이썬 패키지`
- Vector, matrix, n-th array 등의 데이터 분석을 위한 패키지
- 백터 및 행렬 연산에 있어 매우 편리한 기능을 제공
-  `array(배열) 단위로 데이터를 관리하며 이를 연산 수행`
    - Dynamic  type을 지원하지 않는다. 한 타입만 지원
    - 1차원 Numpy array : Vector
    - 2차원 Numpy array : Matrix
    - 3차원 이상 Numpy array : Tensor
- pandas와 matplotlib 기반





## 배열 생성

Numpy를 이용하려면 먼저 임포트(import)해야한다. 통상적으로 np를 별칭으로 한다.


```python
import numpy as np
```



`배열(Array)` : 순서가 있는 같은 종류의 데이터가 저장된 집합. Numpy를 이용해 배열을 처리하기 위해선 Numpy로 배열을 만들어야 한다. 


```python
# 리스트 객체를 이용해 array 생성

data1 = [1,2,3]
data2 = [1,2,3,3.5,5]

arr1 = np.array(data1)
arr1
```


    array([1, 2, 3])




```python
#array 크기 확인
arr1.shape
```


    (3,)




```python
# array 자료형 확인
arr1.dtype
```


    dtype('int32')




```python
# 하나라도 실수(float)가 있으면 데이터가 실수로 변환되어 저장
arr3 = array([1. , 2. , 3. , 3.5, 4. ])
arr3.dtype
```


    dtype('float64')




```python
arr4 = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr4
```


    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])




```python
arr4.shape
```


    (3, 3)



### **arange()**

- 범위를 지정해 배열을 생성한다.  정수값으로 출력한다.


```python
np.arange(10)
```


    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.arange(1,5)
```


    array([1, 2, 3, 4])




```python
np.arange(1,10,2)
```


    array([1, 3, 5, 7, 9])




```python
# 1차원 형태를 2차원 형태로(reshape은 차원을 바꿔준다)
b1 = np.arange(12).reshape(3,4)
```


    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])




```python
b3 = b1.reshape(4,3)
b3
```


    array([[ 0,  1,  2],
           [ 3,  4,  5],
           [ 6,  7,  8],
           [ 9, 10, 11]])



### **linspace() **

- 지정한 간격만큼 배열을 생성한다. 실수값으로 출력한다.


```python
np.linspace(1,10,10)
```


    array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])




```python
np.linspace(0, np.pi, 20)
```


    array([0.        , 0.16534698, 0.33069396, 0.49604095, 0.66138793,
           0.82673491, 0.99208189, 1.15742887, 1.32277585, 1.48812284,
           1.65346982, 1.8188168 , 1.98416378, 2.14951076, 2.31485774,
           2.48020473, 2.64555171, 2.81089869, 2.97624567, 3.14159265])



### zeros()

- 모든 원소를 0인 배열을 만든다.


```python
np.zeros(10,dtype=int)
```


    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])




```python
np.zeros((3,5))
```


    array([[0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.]])



### ones()

- 모든 원소를 1인 배열을 만든다.


```python
np.ones(10)
```


    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])




```python
np.ones((3,5), dtype=int)
```


    array([[1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1]])



### eyes()

- n x n인 정사각형 행렬에서 주 대각선이 모두 1이고 나머지는 0인 행렬을 만든다.


```python
# 3행 3열의 대각요소가 1인 행렬
np.eye(3)
```


    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])




```python
np.eye(3,4)
```


    array([[1., 0., 0., 0.],
           [0., 1., 0., 0.],
           [0., 0., 1., 0.]])




```python
# 한 열을 옆으로 이동
np.eye(3,4, k=1, dtype=int)
```


    array([[0, 1, 0, 0],
           [0, 0, 1, 0],
           [0, 0, 0, 1]])




```python
np.eye(3,4, k=-1)
```


    array([[0., 0., 0., 0.],
           [1., 0., 0., 0.],
           [0., 1., 0., 0.]])





## 배열 연산

- 배열 형태가 같다면 덧셈과 뺄셈, 곱셈과 나눗셈 연산을 할 수 있다. 
- 배열 합, 평균, 표준편차, 분산, 최솟값과 최댓값, 누적 합과 누적 곱 등 통계에서 많이 이용하는 메서드가 있다.
- 선형대수를 위한 행렬(2차원 배열) 연산도 가능하다.



### 기본연산


```python
arr1 = np.array([[1,3,4],[4,3,6]])
arr1
```


    array([[1, 3, 4],
           [4, 3, 6]])




```python
arr2 = np.arange(10,16).reshape(2,3)
arr2
```


    array([[10, 11, 12],
           [13, 14, 15]])




```python
print(arr1.shape, arr2.shape)
```

    (2, 3) (2, 3)



```python
arr1 + arr2
```


    array([[11, 14, 16],
           [17, 17, 21]])




```python
arr1 - arr2
```


    array([[ -9,  -8,  -8],
           [ -9, -11,  -9]])




```python
arr1 * arr2
```


    array([[10, 33, 48],
           [52, 42, 90]])




```python
# 행렬곱 메소드 dot을 쓸 경우 오류가 나온다
# 두 matrix의 행과 열 개수가 일치하지 않기 때문
np.dot(arr1, arr2)
```


    ---------------------------------------------------------------------------
    
    ValueError                                Traceback (most recent call last)
    
    ~\AppData\Local\Temp/ipykernel_13904/1544124386.py in <module>
    ----> 1 np.dot(arr1, arr2)


    <__array_function__ internals> in dot(*args, **kwargs)


    ValueError: shapes (2,3) and (2,3) not aligned: 3 (dim 1) != 2 (dim 0)



```python
arr1 / arr2
```


    array([[0.1       , 0.27272727, 0.33333333],
           [0.30769231, 0.21428571, 0.4       ]])




```python
arr2 * 2
```


    array([[20, 22, 24],
           [26, 28, 30]])




```python
arr2 > 13
```


    array([[False, False, False],
           [False,  True,  True]])



### 배열의 Broadcasting

- 서로 크기가 다른 array들의 연산이 가능하도록 배열을 자동으로 변환해 연산 수행


```python
arr1
```


    array([[1, 3, 4],
           [4, 3, 6]])


```python
arr3 = np.array([10,11,12])
arr3
```




```python
(arr1.shape, arr3.shape)
```


    ((2, 3), (3,))




```python
arr1 + arr3
```


    array([[11, 14, 16],
           [14, 14, 18]])




```python
arr1 ** 2
```


    array([[ 1,  9, 16],
           [16,  9, 36]], dtype=int32)

참고 : http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html



### 통계를 위한 연산


```python
arr1 = np.arange(5)
arr1
```


    array([0, 1, 2, 3, 4])




```python
# 합과 (산술)평균 : sum(), mean()
[arr1.sum(), arr1.mean()]
```


    [10, 2.0]




```python
# 표준편차와 분산 : std(), var()
[arr1.std(), arr1.var()]
```


    [1.4142135623730951, 2.0]




```python
# 최소값과 최대값 :min(), max()
[arr1.min(), arr1.max()]
```


    [0, 4]




```python
# 누적합과 누적곱 : cumsum(), cumprod()
arr2 = np.arange(1,5)
arr2
```


    array([1, 2, 3, 4])


```python
# 누적합
arr2.cumsum()
```


    array([ 1,  3,  6, 10], dtype=int32)


```python
# 누적곱
arr2.cumprod()
```


    array([ 1,  2,  6, 24], dtype=int32)




```python
A = np.arange(1,5).reshape(2,2)
# A = np.array([[1,2],[3,4]])
# A = np.array([1,2,3,4]).reshape(2,2)
A
```


    array([[1, 2],
           [3, 4]])




```python
B = np.array([3,2,0,1]).reshape(2,2)
B
```


    array([[3, 2],
           [0, 1]])




```python
# 행렬의 곱 : 첫번째 row(m x n), 두번째 cloumn(n x p) 크기가 서로 같아야함(n = n) 
# 첫번째 행과 두번째 열의 요소를 하나하나 곱해서 더해줌. 결과는 m x p
```


```python
# A.dot(B)
np.dot(A,B)
```


    array([[ 3,  4],
           [ 9, 10]])




```python
# 연산자 *를 이용한 이 경우와는 어떤 차이지?
A * B
```


    array([[3, 4],
           [0, 4]])




```python
# 전치행렬 : 행과 열을 바꿈(3,4) => (4,3) i,j => j,i
# A.transpose()
np.transpose(A)
```


    array([[1, 3],
           [2, 4]])




```python
# 역행렬(inverse) : 3 * 1/3 = 1이 되는 것처럼. 1/3 같은 것. 단위행렬이 나오도록
np.linalg.inv(A)
```


    array([[-2. ,  1. ],
           [ 1.5, -0.5]])




```python
# 행렬 A * inv(A) = I (단위행렬)
np.dot(A, np.linalg.inv(A))
```


    array([[1.00000000e+00, 1.11022302e-16],
           [0.00000000e+00, 1.00000000e+00]])




```python
# 행렬식(determinant) : 행렬을 대표하는 값. 절대값
np.linalg.det(A)
```


    -2.0000000000000004





## 인덱싱과 슬라이싱

- 인덱싱(indexing) : 배열의 위치나 조건을 지정해 배열의 원소를 선택하는 것

- 슬라이싱(slicing) : 범위를 지정해 배열의 원소를 선택하는 것




```python
arr1 = np.arange(10)
arr1
```


    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
# 0번째 요소
arr1[0]
```


    0




```python
# 3번째 요소
arr1[3]
```


    3




```python
# arr1[1,3,4] => 오류가 나온다
# 1,3,4 위치 
# shape : (m, )=> 1차원, (m,n) => 2차원, (m,n,p) => 3차원
# 인덱스 [] : [m] => 1차원, [m,n] => 2차원, [m,n,p] => 3차원
# arr1[1,3,4] => 3차원 배열의 위치 1면 3행 4열

# 여러 인덱스의 요소를 지정 : 리스트로
arr1[[1,3,4]]
```


    array([1, 3, 4])




```python
arr2 = np.arange(1,13).reshape(3,4)
arr2
```


    array([[ 1,  2,  3,  4],
           [ 5,  6,  7,  8],
           [ 9, 10, 11, 12]])




```python
# 2차원의 array에서 인덱싱을 하기 위해선 2개의 인자를 입력해야 한다
# arr2[3,2] #3행2열의 요소. 요류가 나온다.
arr2[2,3]
```


    12




```python
# 0행0열 값 변경
arr2[0,0] = 90
arr2
```


    array([[90,  2,  3,  4],
           [-5,  1, 10,  9],
           [ 9, 10, 11, 12]])




```python
# 두번째 행(1행) 선택
arr2[1]
```


    array([-5,  1, 10,  9])



**2차원배열명[:,열위치]**
: 2차원 배열에서 지정한 열 전체 선택


```python
# 1열 선택 
arr2[:,1]
```


    array([ 2,  1, 10])




```python
# 두번째 행 변경
arr2[1] = [-5,1,10,9]
arr2
```


    array([[ 1,  2,  3,  4],
           [-5,  1, 10,  9],
           [ 9, 10, 11, 12]])




```python
# 0행0열, 2행1열을 가져옴
arr2[[0,2],[0,1]]
```


    array([90, 10])




```python
# 10 이상인 원소 선택. 비교 연산
arr2 > 10
```


    array([[False, False, False, False],
           [False, False, False, False],
           [False, False,  True,  True]])




```python
# 비교연산 결과를 인덱스로 지정
arr2[arr2 > 10]
```


    array([11, 12])




```python
# 짝수인 원소 선택
arr2[arr2 % 2 == 0]
```


    array([ 2,  4, 10, 10, 12])




```python
arr1 = np.arange(10)
arr1
```


    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
# 3번째 요소부터 8번째 요소
arr1[3:9]
```


    array([3, 4, 5, 6, 7, 8])




```python
arr1[3:9:2]
```


    array([3, 5, 7])




```python
arr1[:9:2]
```


    array([0, 2, 4, 6, 8])




```python
arr1[3::2]
```


    array([3, 5, 7, 9])




```python
arr1[::3]
```


    array([0, 3, 6, 9])




```python
arr1[::-1]
```


    array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])




```python
arr1[::-2]
```


    array([9, 7, 5, 3, 1])




```python
arr2
```




    array([[ 1,  2,  3,  4],
           [-5,  1, 10,  9],
           [ 9, 10, 11, 12]])




```python
arr2[2,:]
```


    array([ 9, 10, 11, 12])




```python
arr2[2]
```


    array([ 9, 10, 11, 12])




```python
# 3열 모든 요소 꺼내기
arr2[:,3]
```


    array([ 4,  9, 12])




```python
# 1~2행, 1~2열의 요소
arr2[1:3, 1:3]
```


    array([[ 1, 10],
           [10, 11]])




```python
arr3 = np.arange(10, 100, 10).reshape(3,3)
arr3
```


    array([[10, 20, 30],
           [40, 50, 60],
           [70, 80, 90]])




```python
# 1행의 0열과 1열 요소 선택
arr3[1,:2]
arr3[1][:2]
```


    array([40, 50])




```python
# 참고. 인덱싱예
arr3[2][1]
```


    80




```python
# 0~1행, 1~2열 요소 변경
arr3[:2, 1:3] = np.array([[1,3],[4,1]])
arr3
```


    array([[10,  1,  3],
           [40,  4,  1],
           [70, 80, 90]])






```python
names = np.array(['Beomwoo','Beomwoo','Kim','Joan','Lee','Beomwoo',
                  'Park','Beomwoo'])
names
```


    array(['Beomwoo', 'Beomwoo', 'Kim', 'Joan', 'Lee', 'Beomwoo', 'Park',
           'Beomwoo'], dtype='<U7')




```python
# names 크기
names.shape
```


    (8,)




```python
# 8행4열 실수 난수 배열 생성
data = np.random.randn(8,4)
data
```


    array([[-0.01945307, -0.14330769,  0.22035525,  1.5144193 ],
           [ 0.46993322, -0.44181915, -0.59048847, -0.35461316],
           [ 0.1636337 , -0.17796396, -0.55502935,  0.26143116],
           [ 0.3638848 ,  2.17046556,  0.54207649, -0.44300047],
           [-1.13743657,  0.97321884, -2.06015905, -1.11892427],
           [ 0.79926178,  0.71798183,  1.08182527,  0.7099819 ],
           [ 0.21903513,  1.03404462,  0.29171081,  1.29107274],
           [-0.92797932, -0.58295381,  0.59915437, -1.56242623]])




```python
data.shape
```


    (8, 4)




```python
# 요소가 beomwoo인 항목에 대한 mask 생성
names_mask_Beomwoo = (names == 'Beomwoo')
names_mask_Beomwoo
```


    array([ True,  True, False, False, False,  True, False,  True])




```python
# 요소가 범우인 항목의 위치와 같은 행의 자료 가져오기
data[names_mask_Beomwoo, :]
#data[names_mask_Beomwoo]
```


    array([[-0.01945307, -0.14330769,  0.22035525,  1.5144193 ],
           [ 0.46993322, -0.44181915, -0.59048847, -0.35461316],
           [ 0.79926178,  0.71798183,  1.08182527,  0.7099819 ],
           [-0.92797932, -0.58295381,  0.59915437, -1.56242623]])




```python
# 요소가 kim인 행의 데이터만 꺼내기
data[names == 'Kim', :]
```


    array([[ 0.1636337 , -0.17796396, -0.55502935,  0.26143116]])


```python
data[(names == 'Kim') | (names == 'Park')]
```


    array([[ 0.1636337 , -0.17796396, -0.55502935,  0.26143116],
           [ 0.21903513,  1.03404462,  0.29171081,  1.29107274]])




```python
data[:, 0] < 0
```


    array([ True, False, False, False,  True, False, False,  True])




```python
data[data[:, 0]<0]
```


    array([[-0.01945307, -0.14330769,  0.22035525,  1.5144193 ],
           [-1.13743657,  0.97321884, -2.06015905, -1.11892427],
           [-0.92797932, -0.58295381,  0.59915437, -1.56242623]])




```python
# data[data[:, 0] < 0][:, 2:4]
# data[data[:, 0] < 0, 2:4]
mask = data[:, 0] < 0
mask
```


    array([ True, False, False, False,  True, False, False,  True])


```python
data[mask, 2:4]
```


    array([[ 0.51587078, -0.98775588],
           [ 0.94405881, -0.2524589 ],
           [ 0.13817845, -0.29257857]])




```python
# 5행3열의 실수난수 배열 생성
data = np.random.randn(5,3)
data
```


    array([[ 0.81607587, -0.6017526 ,  0.67542355],
           [-0.18255064, -0.95468216,  0.52379547],
           [-0.05239966,  0.02008645,  2.37982627],
           [ 0.77042917, -0.67471306,  1.7503216 ],
           [-1.60641814, -0.41708252, -0.13284064]])



참고:

https://numpy.org/doc/stable/reference/routines.math.html

https://numpy.org/doc/stable/reference/random/legacy.html

https://numpy.org/doc/stable/reference/routines.statistics.html






```python
# 각 성분의 절대값 계산하기
np.abs(data)
```


    array([[0.81607587, 0.6017526 , 0.67542355],
           [0.18255064, 0.95468216, 0.52379547],
           [0.05239966, 0.02008645, 2.37982627],
           [0.77042917, 0.67471306, 1.7503216 ],
           [1.60641814, 0.41708252, 0.13284064]])




```python
# 각 성분 제곱근 계산하기 : 
np.sqrt(np.abs(data))
```


    array([[0.90336918, 0.77572714, 0.82184156],
           [0.42725945, 0.97707838, 0.72373716],
           [0.22890973, 0.14172666, 1.54266856],
           [0.87774095, 0.82140919, 1.32299721],
           [1.26744552, 0.64581926, 0.3644731 ]])




```python
# 각 성분의 제곱 계산하기
np.square(data)
```


    array([[6.65979827e-01, 3.62106190e-01, 4.56196971e-01],
           [3.33247349e-02, 9.11418034e-01, 2.74361694e-01],
           [2.74572484e-03, 4.03465353e-04, 5.66357308e+00],
           [5.93561113e-01, 4.55237716e-01, 3.06362572e+00],
           [2.58057925e+00, 1.73957827e-01, 1.76466360e-02]])




```python
# 각 성분을 자연대수 e의 지수로 삼은 값을 계산하기 : e^x
np.exp(data)
```


    array([[ 2.26160756,  0.54785063,  1.96486502],
           [ 0.83314246,  0.38493447,  1.68842387],
           [ 0.94894953,  1.02028954, 10.80302591],
           [ 2.16069337,  0.50930254,  5.75645368],
           [ 0.20060487,  0.65896654,  0.87560462]])




```python
# 자연로그
np.log(abs(data))
```


    array([[-0.20324795, -0.50790888, -0.3924153 ],
           [-1.70072768, -0.04637681, -0.646654  ],
           [-2.94885509, -3.90770997,  0.86702749],
           [-0.26080755, -0.39346777,  0.55979955],
           [ 0.47400694, -0.87447119, -2.01860505]])




```python
# 상용로그
np.log10(abs(data))
```


    array([[-0.08826946, -0.22058203, -0.1704238 ],
           [-0.73861665, -0.02014119, -0.28083826],
           [-1.28067149, -1.69709688,  0.37654525],
           [-0.11326728, -0.17088088,  0.24311785],
           [ 0.2058586 , -0.37977801, -0.87666904]])




```python
# 밑이 2인 로그
np.log2(abs(data))
```


    array([[-0.29322481, -0.73275763, -0.56613561],
           [-2.4536314 , -0.06690759, -0.93292451],
           [-4.25429861, -5.63763379,  1.25085626],
           [-0.37626576, -0.567654  ,  0.80762003],
           [ 0.68384747, -1.26159525, -2.9122315 ]])




```python
# 각 성분의 부호 계산하기
np.sign(data)
```


    array([[ 1., -1.,  1.],
           [-1., -1.,  1.],
           [-1.,  1.,  1.],
           [ 1., -1.,  1.],
           [-1., -1., -1.]])




```python
# 각 성분의 소수 첫 번째 자리에서 내림한 값을 계산
np.floor(data)
```


    array([[ 0., -1.,  0.],
           [-1., -1.,  0.],
           [-1.,  0.,  2.],
           [ 0., -1.,  1.],
           [-2., -1., -1.]])




```python
# 각 성분이 NaN인 경우 True를, 아닌 경우 False를 반환
np.isnan(data)
```


    array([[False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False]])




```python
# 로그변환한 배열 중 Nan 확인
np.isnan(np.log(data))
```

    C:\Users\Gram\AppData\Local\Temp/ipykernel_6188/2830797324.py:2: RuntimeWarning: invalid value encountered in log
      np.isnan(np.log(data))

    array([[False,  True, False],
           [ True,  True, False],
           [ True, False, False],
           [False,  True, False],
           [ True,  True,  True]])




```python
# 각 성분이 무한대인 경우 True를, 아닌 경우 False를 반환
np.isinf(data)
```


    array([[False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False]])




```python
# sin()
np.sin(data)
```


    array([[ 0.72846308, -0.56608809,  0.62522793],
           [-0.18153842, -0.81613011,  0.50017033],
           [-0.05237569,  0.0200851 ,  0.69020071],
           [ 0.69644328, -0.62467328,  0.98392857],
           [-0.99936561, -0.4050948 , -0.13245029]])




```python
# cos()
np.cos(data)
```


    array([[ 0.68508506,  0.82434476,  0.78044221],
           [ 0.98338385,  0.57786818,  0.86592704],
           [ 0.99862745,  0.99979827, -0.72361798],
           [ 0.71761184,  0.78088623, -0.1785625 ],
           [-0.03561428,  0.91427469,  0.99118965]])




```python
# tan()
np.tan(data)
```


    array([[ 1.06331772e+00, -6.86712790e-01,  8.01120088e-01],
           [-1.84605854e-01, -1.41231191e+00,  5.77612558e-01],
           [-5.24476756e-02,  2.00891488e-02, -9.53819175e-01],
           [ 9.70501383e-01, -7.99954277e-01, -5.51027548e+00],
           [ 2.80608095e+01, -4.43077783e-01, -1.33627594e-01]])




```python
data
```


    array([[-0.01945307, -0.14330769,  0.22035525,  1.5144193 ],
           [ 0.46993322, -0.44181915, -0.59048847, -0.35461316],
           [ 0.1636337 , -0.17796396, -0.55502935,  0.26143116],
           [ 0.3638848 ,  2.17046556,  0.54207649, -0.44300047],
           [-1.13743657,  0.97321884, -2.06015905, -1.11892427],
           [ 0.79926178,  0.71798183,  1.08182527,  0.7099819 ],
           [ 0.21903513,  1.03404462,  0.29171081,  1.29107274],
           [-0.92797932, -0.58295381,  0.59915437, -1.56242623]])




```python
# 전체 성분 합을 계산
np.sum(data)
```


    2.313518959366195




```python
# 같은 열을 갖는 행의 요소를 합한 결과(axis=0) => 세로로 더하는 것 [ : , i]
np.sum(data, axis=0)
```


    array([-0.06912034,  3.54966624, -0.47055469,  0.29794096])




```python
# 같은 행을 갖는 열의 요소를 합한 결과(axis=0) => 가로로 더하는 것 [ i, : ]
np.sum(data, axis=1)
```


    array([ 1.57201379, -0.91698757, -0.30792845,  2.63342638, -3.34330105,
            3.30905078,  2.83586329, -2.47420499])




```python
# 행별로 평균 계산 axis = 1
np.mean(data, axis=1)
```


    array([ 0.39300345, -0.22924689, -0.07698211,  0.6583566 , -0.83582526,
            0.82726269,  0.70896582, -0.61855125])




```python
data
```


    array([[-0.01945307, -0.14330769,  0.22035525,  1.5144193 ],
           [ 0.46993322, -0.44181915, -0.59048847, -0.35461316],
           [ 0.1636337 , -0.17796396, -0.55502935,  0.26143116],
           [ 0.3638848 ,  2.17046556,  0.54207649, -0.44300047],
           [-1.13743657,  0.97321884, -2.06015905, -1.11892427],
           [ 0.79926178,  0.71798183,  1.08182527,  0.7099819 ],
           [ 0.21903513,  1.03404462,  0.29171081,  1.29107274],
           [-0.92797932, -0.58295381,  0.59915437, -1.56242623]])




```python
# 전체 성분 최소값, 최대값이 있는 인덱스를 반환
[np.argmax(data), np.argmin(data)]
# [np.max(data), np.min(data)]
```


    [13, 18]




```python
np.argmax(data, axis=1)
```


    array([3, 0, 3, 1, 1, 2, 3, 2], dtype=int64)




```python
np.cumsum(data)
```


    array([ 0.81607587,  0.21432327,  0.88974682,  0.70719619, -0.24748598,
            0.27630949,  0.22390983,  0.24399627,  2.62382254,  3.39425172,
            2.71953866,  4.46986026,  2.86344212,  2.4463596 ,  2.31351896])




```python
np.cumsum(data, axis=0)
```


    array([[ 0.81607587, -0.6017526 ,  0.67542355],
           [ 0.63352523, -1.55643476,  1.19921902],
           [ 0.58112557, -1.53634832,  3.57904529],
           [ 1.35155474, -2.21106138,  5.3293669 ],
           [-0.2548634 , -2.6281439 ,  5.19652625]])




```python
np.cumprod(data)
```


    array([ 8.16075871e-01, -4.91075776e-01, -3.31684144e-01,  6.05491516e-02,
           -5.78051950e-02, -3.02780993e-02,  1.58656225e-03,  3.18683985e-05,
            7.58412519e-05,  5.84303131e-05, -3.94236954e-05, -6.90041458e-05,
            1.10849512e-04, -4.62333936e-05,  6.14167366e-06])




```python
np.cumprod(data, axis=1)
```


    array([[ 8.16075871e-01, -4.91075776e-01, -3.31684144e-01],
           [-1.82550636e-01,  1.74277837e-01,  9.12859413e-02],
           [-5.23996645e-02, -1.05252308e-03, -2.50482209e-03],
           [ 7.70429174e-01, -5.19818627e-01, -9.09849773e-01],
           [-1.60641814e+00,  6.70008925e-01, -8.90044154e-02]])




```python
data
```


    array([[ 0.81607587, -0.6017526 ,  0.67542355],
           [-0.18255064, -0.95468216,  0.52379547],
           [-0.05239966,  0.02008645,  2.37982627],
           [ 0.77042917, -0.67471306,  1.7503216 ],
           [-1.60641814, -0.41708252, -0.13284064]])




```python
# 전체 성분을 오름차순으로 정렬(행별로!)
np.sort(data)
```


    array([[-0.14330769, -0.01945307,  0.22035525,  1.5144193 ],
           [-0.59048847, -0.44181915, -0.35461316,  0.46993322],
           [-0.55502935, -0.17796396,  0.1636337 ,  0.26143116],
           [-0.44300047,  0.3638848 ,  0.54207649,  2.17046556],
           [-2.06015905, -1.13743657, -1.11892427,  0.97321884],
           [ 0.7099819 ,  0.71798183,  0.79926178,  1.08182527],
           [ 0.21903513,  0.29171081,  1.03404462,  1.29107274],
           [-1.56242623, -0.92797932, -0.58295381,  0.59915437]])




```python
# 전체 성분에 [::-1]를 적용 => 정렬 후 마지막행부터 표시
np.sort(data)[::-1]
```


    array([[-1.56242623, -0.92797932, -0.58295381,  0.59915437],
           [ 0.21903513,  0.29171081,  1.03404462,  1.29107274],
           [ 0.7099819 ,  0.71798183,  0.79926178,  1.08182527],
           [-2.06015905, -1.13743657, -1.11892427,  0.97321884],
           [-0.44300047,  0.3638848 ,  0.54207649,  2.17046556],
           [-0.55502935, -0.17796396,  0.1636337 ,  0.26143116],
           [-0.59048847, -0.44181915, -0.35461316,  0.46993322],
           [-0.14330769, -0.01945307,  0.22035525,  1.5144193 ]])




```python
# 열별로 오름차순 정렬(아래 방향으로)
np.sort(data, axis=0)
```


    array([[-1.13743657, -0.58295381, -2.06015905, -1.56242623],
           [-0.92797932, -0.44181915, -0.59048847, -1.11892427],
           [-0.01945307, -0.17796396, -0.55502935, -0.44300047],
           [ 0.1636337 , -0.14330769,  0.22035525, -0.35461316],
           [ 0.21903513,  0.71798183,  0.29171081,  0.26143116],
           [ 0.3638848 ,  0.97321884,  0.54207649,  0.7099819 ],
           [ 0.46993322,  1.03404462,  0.59915437,  1.29107274],
           [ 0.79926178,  2.17046556,  1.08182527,  1.5144193 ]])




```python
# 행별로 오름차순 정렬(오른쪽 방향으로)
np.sort(data, axis=1)
```


    array([[-0.14330769, -0.01945307,  0.22035525,  1.5144193 ],
           [-0.59048847, -0.44181915, -0.35461316,  0.46993322],
           [-0.55502935, -0.17796396,  0.1636337 ,  0.26143116],
           [-0.44300047,  0.3638848 ,  0.54207649,  2.17046556],
           [-2.06015905, -1.13743657, -1.11892427,  0.97321884],
           [ 0.7099819 ,  0.71798183,  0.79926178,  1.08182527],
           [ 0.21903513,  0.29171081,  1.03404462,  1.29107274],
           [-1.56242623, -0.92797932, -0.58295381,  0.59915437]])




```python
data1 = np.random.randn(5,3)
data2 = np.random.randn(5,3)
```


```python
print(data1)
print(data2)
```

    [[ 0.90568382  0.71416024  0.6208254 ]
     [-0.82189592 -0.37947498 -0.6732907 ]
     [ 1.17897146 -1.29707242  0.91723519]
     [ 0.22707727 -0.27970934 -0.74430249]
     [-0.03927122 -0.06308933  0.72165915]]
    [[-0.63685565 -0.2620909   0.5158282 ]
     [ 0.67092245 -1.12776686 -0.7882344 ]
     [-0.53200855 -0.88274748 -0.51648009]
     [-0.29151768 -1.47224288 -0.97582125]
     [-1.1949502  -0.44400648 -0.89532018]]



```python
# 두 배열의 합
np.add(data1, data2)
```


    array([[ 0.26882817,  0.45206933,  1.1366536 ],
           [-0.15097347, -1.50724184, -1.46152509],
           [ 0.64696291, -2.1798199 ,  0.4007551 ],
           [-0.06444041, -1.75195222, -1.72012374],
           [-1.23422142, -0.50709581, -0.17366103]])




```python
# 두 배열의 차
np.subtract(data1, data2)
```


    array([[ 1.67615288,  0.7800684 ,  1.05759522],
           [ 0.81439057,  0.72107643, -0.7138749 ],
           [ 1.40353979, -1.47462524, -2.44552276],
           [-1.11800454,  2.24327914,  1.67260357],
           [ 1.02697294,  1.58339549, -2.75290103]])




```python
# 두 배열의 합
np.multiply(data1, data2)
```


    array([[-0.57678985, -0.1871749 ,  0.32023925],
           [-0.55142843,  0.42795931,  0.53071089],
           [-0.6272229 ,  1.14498741, -0.47373372],
           [-0.06619704,  0.41180008,  0.72630619],
           [ 0.04692715,  0.02801207, -0.646116  ]])




```python
data1 * data2
```


    array([[-0.57678985, -0.1871749 ,  0.32023925],
           [-0.55142843,  0.42795931,  0.53071089],
           [-0.6272229 ,  1.14498741, -0.47373372],
           [-0.06619704,  0.41180008,  0.72630619],
           [ 0.04692715,  0.02801207, -0.646116  ]])




```python
# 두 배열의 합
np.divide(data1, data2)
```


    array([[-1.41240909, -3.0877037 ,  0.19843951],
           [-6.87597394, -0.15641464,  2.74894642],
           [-0.47000756,  4.96660175, -0.98840054],
           [-0.8295754 , -0.82810072, -1.3022722 ],
           [-0.27476844,  0.1660663 , -0.65684713]])




```python
# 두 개의 array에 동일한 위치의 성분끼리 비교해서
# 최대값 또는 최소값 계산하기
np.maximum(data1, data2)
```


    array([[ 0.9813483 ,  0.58923549, -0.26182513],
           [ 0.71098869,  0.09753155, -0.40817425],
           [ 0.44875573, -0.37176035,  1.22989443],
           [ 0.61107322,  1.01616998,  0.94610235],
           [ 0.22135766, -0.3153112 ,  1.66152988]])




```python
np.minimum(data1, data2)
```


    array([[-0.69480458, -0.19083291, -1.31942035],
           [-0.10340189, -0.62354488, -1.12204915],
           [-0.95478406, -1.84638559, -1.21562833],
           [-0.50693132, -1.22710916, -0.72650122],
           [-0.80561528, -1.89870669, -1.09137114]])



형변환


```python
np.array(['1.5','0.62','2','3.14','3.141592'])
```


    array(['1.5', '0.62', '2', '3.14', '3.141592'], dtype='<U8')




```python
# 문자열을 실수형으로 형 변환
# 보통 메소드 앞에 is가 있으면 ~가 있는지 확인, as는 형변환을 의미
str_a1 = np.array(['1.5','0.62','2','3.14','3.141592'])
# num_a1 = str_a1.astype('float32')
num_a1 = str_a1.astype(float)
num_a1
```


    array([1.5     , 0.62    , 2.      , 3.14    , 3.141592])




```python
# 문자형 => 실수형 => 정수형으로 바꿀 수 있다
num_a2 = num_a1.astype(int)
num_a2
```


    array([1, 0, 2, 3, 3])




```python
# 오류가 나온다
num_a5 = str_a1.astype(int)
num_a5
```


    ---------------------------------------------------------------------------
    
    ValueError                                Traceback (most recent call last)
    
    ~\AppData\Local\Temp/ipykernel_13920/2190938134.py in <module>
    ----> 1 num_a4 = str_a1.astype(int)
          2 num_a4


    ValueError: invalid literal for int() with base 10: '1.5'



```python
str_a1.dtype
```


    dtype('<U8')




```python
# 실수를 표현하는 방식의 차이(32비트, 64비트)
num_a1.dtype
```


    dtype('float64')




```python
str_a2 = np.array(['1','3','5','7','9'])
num_a3 = str_a2.astype(int)
num_a3
```


    array([1, 3, 5, 7, 9])




```python
num_a4 = str_a2.astype(float)
num_a4
```


    array([1., 3., 5., 7., 9.])




```python
num_f1 = np.array([10, 21, 0.549, 4.75, 5.98])
num_f1
```


    array([10.   , 21.   ,  0.549,  4.75 ,  5.98 ])




```python
num_i1 = num_f1.astype(int)
num_i1
```


    array([10, 21,  0,  4,  5])




```python
# 반올림
num_b = np.around(num_f1)
num_b
```


    array([10., 21.,  1.,  5.,  6.])




```python
num_f1.dtype
```


    dtype('float64')




```python
num_i1.dtype
```


    dtype('int32')




```python
num_f1.astype('U')
```


    array(['10.0', '21.0', '0.549', '4.75', '5.98'], dtype='<U32')




```python
num_f1.astype('S')
```


    array([b'10.0', b'21.0', b'0.549', b'4.75', b'5.98'], dtype='|S32')




```python
np.random.rand(10)
np.random.rand(2,5)
```


    array([0.38861103, 0.77318349, 0.8445972 , 0.24533392, 0.15573818,
           0.62786979, 0.84280126, 0.83881932, 0.20220347, 0.17240719])




```python
np.random.rand(2,3,4)
```


    array([[[0.21855298, 0.79100593, 0.94735812, 0.67020358],
            [0.89492042, 0.63296679, 0.31548729, 0.43513757],
            [0.80659814, 0.29651408, 0.93085794, 0.88466723]],
    
           [[0.87720395, 0.56416727, 0.0345216 , 0.68571498],
            [0.33346708, 0.35199498, 0.01185933, 0.8888391 ],
            [0.54699028, 0.49109282, 0.92660258, 0.57500062]]])




```python
np.random.randint(10)
```


    3




```python
np.random.randint(10, 20)
```


    19




```python
np.random.randint(10, 20, size=(3,5))
```


    array([[15, 10, 14, 19, 12],
           [17, 13, 10, 11, 10],
           [14, 19, 18, 17, 13]])



